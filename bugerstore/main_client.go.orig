package main

import (
	"flag"
	"fmt"
	"os"
	"time"

	apiextensionsclientset "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/klog"
	controller "satya.com/burgerstore/pkg/cmd"

	burgerStoreClient "satya.com/burgerstore/pkg/generated/clientset/versioned"
	informers "satya.com/burgerstore/pkg/generated/informers/externalversions"
)

func NewClient(masterUrl, kubeconfigPath string) (*burgerStoreClient.Clientset, error) {
	// use the current context in kubeconfig
	config, err := clientcmd.BuildConfigFromFlags(masterUrl, kubeconfigPath)
	if err != nil {
		fmt.Printf("error creating dynamic client: %v\n", err)
		os.Exit(1)
	}
	// create the clientset
	return burgerStoreClient.NewForConfig(config)
}

func NewDynamicClient(masterUrl, kubeconfigPath string) (dynamic.Interface, error) {
	// use the current context in kubeconfig
	config, err := clientcmd.BuildConfigFromFlags(masterUrl, kubeconfigPath)
	if err != nil {
		fmt.Printf("error creating dynamic client: %v\n", err)
		os.Exit(1)
	}
	// create the clientset
	return dynamic.NewForConfig(config)
}

func NewApiExtensionClient(masterUrl, kubeconfigPath string) apiextensionsclientset.Interface {
	// use the current context in kubeconfig
	config, err := clientcmd.BuildConfigFromFlags(masterUrl, kubeconfigPath)
	if err != nil {
		fmt.Printf("error creating dynamic client: %v\n", err)
		os.Exit(1)
	}

	apiextensionsClient := apiextensionsclientset.NewForConfigOrDie(config)

	// create the clientset
	return apiextensionsClient
}

func NewK8sClient(masterUrl, kubeconfigPath string) (kubernetes.Interface, error) {
	// use the current context in kubeconfig
	config, err := clientcmd.BuildConfigFromFlags(masterUrl, kubeconfigPath)
	if err != nil {
		fmt.Printf("error creating dynamic client: %v\n", err)
		os.Exit(1)
	}

	// create the clientset
	return kubernetes.NewForConfig(config)
}

func main() {
	kubeConfigPath := "/Users/sdillikar/kind-basic.yaml"
	namespace := "default"
	dyn_controller.dyn_main(kubeConfigPath, namespace)

}
func main2() {
	kubeConfigPath := "/Users/sdillikar/kind-basic.yaml"
	namespace := "default"

	//	klog.SetOutput(os.Stderr)
	klog.SetOutput(os.Stdout)
	klog.InitFlags(nil) // initializing the flags
	defer klog.Flush()  // flushes all pending log I/O

	flag.Parse() // parses the command-line flags

	klog.Info("now you can see me")
	klog.V(4).Info("V4- now you can see me")
	fmt.Printf("Using kubeconfig: %s\n", kubeConfigPath)

	myK8sClient, _ := NewK8sClient("", kubeConfigPath)

	apiExtensionClient := NewApiExtensionClient("", kubeConfigPath)

	// ListPods(myK8sClient, namespace)
	// podname := "testfoo"
	// pod, _ := CreatePod(myK8sClient, namespace, podname)
	// _ = pod
	// time.Sleep(5 * time.Second)
	// pod, _ = GetPod(myK8sClient, namespace, podname)
	// time.Sleep(5 * time.Second)
	// pod, _ = UpdatePod(myK8sClient, namespace, pod)
	// time.Sleep(5 * time.Second)
	// DeletePod(myK8sClient, namespace, pod.Name)

	// ListConfigMaps(myK8sClient, namespace)
	// configmapname := "default-ns-rbac"
	// GetConfigMap(myK8sClient, namespace, configmapname)
	// cmname := "testfoo-cm"
	// cm, _ := CreateConfigMap(myK8sClient, namespace, cmname)
	// _ = cm
	// time.Sleep(5 * time.Second)
	// cm, _ = GetConfigMap(myK8sClient, namespace, cmname)
	// time.Sleep(5 * time.Second)
	// cm, _ = UpdateConfigMap(myK8sClient, namespace, cm)
	// time.Sleep(5 * time.Second)
	// DeleteConfigMap(myK8sClient, namespace, cm.Name)

	myNewClient, _ := NewClient("", kubeConfigPath)
	// ListCRDObject(myNewClient, namespace)
	// CRDObjectObjectName := "object1"
	// GetCRDObject(myNewClient, namespace, CRDObjectObjectName)
	CRDObjectObjectName := "testfoo-crd1"
	// crd, _ := CreateCRDObject(myNewClient, namespace, CRDObjectObjectName)
	// _ = crd
	// time.Sleep(5 * time.Second)
	// crd, _ = GetCRDObject(myNewClient, namespace, CRDObjectObjectName)
	// time.Sleep(5 * time.Second)
	// crd, _ = UpdateCRDObject(myNewClient, namespace, crd)
	// _ = crd
	// time.Sleep(5 * time.Second)
	// DeleteCRDObject(myNewClient, namespace, CRDObjectObjectName)

	//kubeInformerFactory := kubeinformers.NewSharedInformerFactory(myK8sClient, time.Second*30)
	exampleInformerFactory := informers.NewSharedInformerFactory(myNewClient, time.Second*30)

	stopCh := make(chan struct{})
	c := controller.NewController(myK8sClient, myNewClient, apiExtensionClient,
		exampleInformerFactory.Burgerstore().V1alpha1().BurgerStores())

	c.CreateCRD()

	crd, err := controller.CreateCRDObject(myNewClient, namespace, CRDObjectObjectName)

	if err != nil {
		klog.Infoln(err)
	}

	_ = crd

	// myDynamicClient, _ := NewDynamicClient("", kubeConfigPath)

	// unsObject, err := myDynamicClient.Resource(schema.GroupVersionResource{
	// 	Group:    "burgerstore.dev",
	// 	Version:  "v1alpha1",
	// 	Resource: "burgerstore",
	// }).Namespace(namespace).Get(context.TODO(), "object2", metav1.GetOptions{})
	// if err != nil {
	// 	fmt.Printf("error %s getting resource from dyn client\n", err.Error())
	// }

	// brgs := v1alpha1.BurgerStore{}
	// // getting and setting fields on unsObject
	// fmt.Printf("Go the object %s\n", unsObject.GetName())

	// // how do I convert unsObject into a typed object
	// err = runtime.DefaultUnstructuredConverter.FromUnstructured(unsObject.UnstructuredContent(), &brgs)
	// if err != nil {
	// 	fmt.Printf("error %s, converting unstructured to kluster type", err.Error())
	// }
	// fmt.Printf("the concrete type that we got is %+v\n", brgs)

	// notice that there is no need to run Start methods in a separate goroutine. (i.e. go kubeInformerFactory.Start(stopCh)
	// Start method is non-blocking and runs all registered informers in a dedicated goroutine.
	//kubeInformerFactory.Start(stopCh)
	exampleInformerFactory.Start(stopCh)

	if err := c.Run(1, stopCh); err != nil {
		klog.Fatalf("Error running controller: %s", err.Error())
	}
}
